# 区块链技术与应用



## BTC-密码学原理

- 比特币：一种加密货币 crypto-currency

- 密码学中的哈希函数：cryptographic hash function

  - 有三个性质：

    1. collision resistance x!=y H(x)=H(y) 可以用于文件加密。有一个信息m，H(m) 被称为 message digest，信息摘要。可以检测信息摘要判断m有没有被篡改。
    2. hiding  哈希计算是单项不可逆的。可以和collision rsistance结合，达成digital commitment（digital equivalent of a sealed envelope）。先公布H(x)，等真的要公布x的时候再公布x。实际操作中当x的分布不均匀或者样本不够大的时候可以拼接随机数，H(x||nonce)
    3. puzzel freindly。 哈希值的计算事先不可预测。挖矿就是大量去试block header中最后拼接的nonce，使得哈希值小于目标阈值

    ![image-20230619093651946](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619093651946.png)

  - 挖矿常用算法：
    - SHA-256 Secure Hash Algorithm 满足以上三个性质

- 签名

  - 比特币系统个人想要开一个账户：去中心化，每个用户自己开户，创立一个公钥和私钥对（public key， private key）公钥相当于账户，私钥相当于密码
  - 公私钥来源于非对称加密 asymmetric encrytion algorithm，给，给个人发信息，加密用他的公钥，他自己解密用私钥
  - 实际过程，本人想发布交易的时候，就用私钥做签名，发布到网络里，所有人可以用公钥做验证
  - 假设公私钥的产生有一个好的随机源 a good source of randomness
  - 生成和签名的时候都需要好的随机源



## BTC-数据结构

- 哈希指针 hash pointers 存储了指向结构体位置的信息，还存储了结构体哈希值的信息
- ![image-20230619095145726](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095145726.png)
- 区块链和普通链表的区别：
  1. 用哈希指针代表普通链表，每一个block都存了上一个的哈希值。这样任何一个block修改过了都会导致后面的所有block的哈希值变化，达到tamper-evident log 篡改记录。这样我们可以只保存最近的n个节点，需要之前的了问别人要，然后验证一下就行。

​		![image-20230619095310724](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095310724.png)

- merkle tree 最下面是data blocks，保存transactions，上层都是blocks的哈希指针，并且两两组成blcok再做哈希，最后会得到root hash。

![image-20230619095848897](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095848897.png)

- block header保存哈希值，block body保存所有的交易信息
- 全节点有block header和block body， 轻节点只有block body。轻节点的交易验证需要用merkel proof，也就是对应的交易一路往上直到根节点的这条路径。

![image-20230619100857659](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619100857659.png)

实现上，轻节点可以计算自己的tx对应的哈希，然后向全节点请求对应交易的merkel proof的哈希值，这些红色的哈希值不断和轻节点自己计算的绿色哈希值再算哈希，最后得到根哈希，完成验证。



## BTC-共识协议

- 数字货币主要问题：花两次攻击 double spending attack 数字货币是一个文件，我复制多份就可以不断花出去。

- 改进方案：给每一个数字货币一个编号，并且记录对应编号的数字货币属于哪个人，每次交易的时候都向央行确认是否匹配。问题：太麻烦，不是去中心化
- 数字货币系统需要解决两个问题：
  - 什么时候谁来发行
  - 怎么处理花两次攻击
- 先设计如何解决花两次攻击：
  - ![image-20230620104730367](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230620104730367.png)
  - 使用区块链——哈希指针来构成交易。比如：最开始有一个铸币交易，A获得了10个币，接下来他把这十个币分发给B和C，并且由A的私钥、B的公钥、C的公钥等信息进行签名，同时A还会有一个指向自己比特币来源的哈希指针。这些共同构成一个交易block。以此类推可以不断交易。当出现非法交易，比如B已经把5个币给被人了，现在又想给F5个币，这个交易block在回溯整个区块链进行验证时候就会发现，B指向的来源已经被B花掉了，交易终止。

- 比特币的地址是由某个人的公钥进行哈希后进行一系列计算得到了。这部分的安全保障基于非对称加密系统。比如有B‘用自己的公钥创建一个交易说转给了B。如何解决这种伪造的问题。其实就是靠指向来源的哈希指针，来源的哈希指针存储了接收方的公钥的哈希值。一个交易发送方地址的哈希和发送方来源的哈希值匹配的时候才知道发送方是合法的。同时交易block本身使用发送方的私钥进行签名。整体保证了安全性。在比特币系统中使用脚本实现。后面细讲。
- block包含什么
- ![image-20230620110634619](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230620110634619.png)
  - block header
    - version
    - hash of previous block header
    - merkel root hash
    - target  H(block header) <= target 
    - nonce
  - block body
    - transaction list

- full node ( fully validating node) 保存所有信息，验证所有交易
- light node 只保存block header， 没法独立验证交易。系统中大部分是轻节点。只是利用区块链的性质和信息做一些查询



- 分布式共识 distributed consensus
  - 分布式哈希表 distributed hash table
  - CAP Theorm 三者只能实现两个
    - Consistency 达成共识
    - Availability 可使用性
    - Partition tolorence
  - 著名协议：Paxos 



- 比特币中的共识
  - 有些节点可能有恶意，如何设计共识协议
    - 是否可以使用投票的方式，超过半数的节点支持创建block，就创建
    - 任何基于投票的方案会涉及到membership的问题，谁有资格投票
    - sybil attack 女巫攻击：有恶意的节点创建超过半数的账户，就获得了投票的掌控权。
  - 简单的投票是不行的，用计算力来投票。每个节点都可以组装出自己认为合法的block，里面包含一堆交易。然后尝试各种nonce值（4bytes），尝试使得H(block header) <= target 。找了符合的nonce获得了记账权。其他节点在这个节点发布之后先验证target是不是符合难度要求，然后nonce是不是符合。之后验证所有的交易，1经过验证，2来源可靠没有被花过。
  - block必须被加在最长合法链子上的。longest valid chain。 对应的可能有forking attack，加载在中间block导致回滚。
  - 如果出现差不多时间两个节点都发布了block，那么会持续一段时间一个节点后面有两个节点的情况，直到某个节点选择了其中一个进行扩展，这个时候就确定了最长合法链，另外一个就变成了orphan block被抛弃。
  - 出块奖励block reward 引出下一个问题：谁来发布比特币：



- 铸币交易 coinbase transaction
  - 唯一可以生产比特币的权限，比特币的唯一来源
  - 前21万个交易节点获得记账权可以获得50个BTC，过了就减半变成25个。再过21万个再减半。



## BTC实现

- 比特币采用基于账本的交易模式 transaction-based ledger
- 每个账户有多少钱需要靠交易进行推算
- 全节点维护UTXO数据结构：Unspent Transaction Output 所有还没有被花掉的交易的集和
  - 一个交易可能有多个输出，比如A给B转5个，给C转3个，如果B花掉了，C没有花掉，那么就是B的交易不在UTXO里，C的还在
  - 同个交易可能有的输出在有的不在
  - 每个UTXO的输出需要对应交易的哈希和所在交易的第几个输出
  - 用于判断某个币是否是合法的，快速检测是否是double spending

- total inputs = transaction fee + total outputs 有些交易可能input会多一点，因为要给一点到发布交易的区块。这就是除了出块奖励以外的交易小费
- 21万个区块大概是4年的时间产生。所以以后出块奖励很少的时候可能交易小费就很重要了。

- 和比特币对应的是account-based ledger比如以太坊。会显式记录所有账户的币。



- ![image-20230621091052934](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230621091052934.png)

这是某个block的一些具体信息

- ![image-20230621091118293](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230621091118293.png)

这是block header的数据结构。注意nonce，类型是32位无符号整数，最多就2^32个取值，很有可能找不到符合的nonce（最近几年挖矿难度大幅提升）。

那还有什么数据是可以更改去扩大搜索空间的嘛？我们可以更改merkle root的哈希值。通过更改coinbase tx中的coinsbase域，把这8个字节当做一个extra nonce。这样就扩大搜索空间到2^96。所以实际过程会有两个循环，第一层是调整coinbase，在算出对应的merkle root的哈希之后调整nonce。



![image-20230621091808040](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230621091808040.png)

- 这是一个普通交易的信息，有两个输入和两个输出。可以看到输入输出都是scripts，把这个交易的input和上一个的output的脚本拼接在一起可以顺利执行就是合法的。
- ![image-20230621092201203](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230621092201203.png)

- 系统中比特币的总量：21w\*50 + 12w\*12.5+... = 2100w
- 对于去中心化的机制来说，挖矿本身是在维护系统的安全。因为只要大部分节点都是诚实节点，那我们的系统就是安全的。我们没办法保证节点都是诚实的，但是有恶意的节点没有办法偷币（伪造交易），也没有办法double spending。因为大部分节点都是诚实的，只会在最长合法链上进行加区块。所有对各种攻击的防范都是基于诚实节点的算力bi恶意节点算力大很多进行的。
- 防止回滚的办法：confirmation。
  - ![image-20230621095535756](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230621095535756.png)

- selfish mining：挖到了先不发布继续挖，等挖到第二个了一起发布，让其他挖到的人做无用功。高风险，高收益。





















