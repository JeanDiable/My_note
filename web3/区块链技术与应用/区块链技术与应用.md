# 区块链技术与应用



## BTC-密码学原理

- 比特币：一种加密货币 crypto-currency

- 密码学中的哈希函数：cryptographic hash function

  - 有三个性质：

    1. collision resistance x!=y H(x)=H(y) 可以用于文件加密。有一个信息m，H(m) 被称为 message digest，信息摘要。可以检测信息摘要判断m有没有被篡改。
    2. hiding  哈希计算是单项不可逆的。可以和collision rsistance结合，达成digital commitment（digital equivalent of a sealed envelope）。先公布H(x)，等真的要公布x的时候再公布x。实际操作中当x的分布不均匀或者样本不够大的时候可以拼接随机数，H(x||nonce)
    3. puzzel freindly。 哈希值的计算事先不可预测。挖矿就是大量去试block header中最后拼接的nonce，使得哈希值小于目标阈值

    ![image-20230619093651946](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619093651946.png)

  - 挖矿常用算法：
    - SHA-256 Secure Hash Algorithm 满足以上三个性质

- 签名

  - 比特币系统个人想要开一个账户：去中心化，每个用户自己开户，创立一个公钥和私钥对（public key， private key）公钥相当于账户，私钥相当于密码
  - 公私钥来源于非对称加密 asymmetric encrytion algorithm，给，给个人发信息，加密用他的公钥，他自己解密用私钥
  - 实际过程，本人想发布交易的时候，就用私钥做签名，发布到网络里，所有人可以用公钥做验证
  - 假设公私钥的产生有一个好的随机源 a good source of randomness
  - 生成和签名的时候都需要好的随机源



## BTC-数据结构

- 哈希指针 hash pointers 存储了指向结构体位置的信息，还存储了结构体哈希值的信息
- ![image-20230619095145726](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095145726.png)
- 区块链和普通链表的区别：
  1. 用哈希指针代表普通链表，每一个block都存了上一个的哈希值。这样任何一个block修改过了都会导致后面的所有block的哈希值变化，达到tamper-evident log 篡改记录。这样我们可以只保存最近的n个节点，需要之前的了问别人要，然后验证一下就行。

​		![image-20230619095310724](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095310724.png)

- merkle tree 最下面是data blocks，保存transactions，上层都是blocks的哈希指针，并且两两组成blcok再做哈希，最后会得到root hash。

![image-20230619095848897](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619095848897.png)

- block header保存哈希值，block body保存所有的交易信息
- 全节点有block header和block body， 轻节点只有block body。轻节点的交易验证需要用merkel proof，也就是对应的交易一路往上直到根节点的这条路径。

![image-20230619100857659](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230619100857659.png)

实现上，轻节点可以计算自己的tx对应的哈希，然后向全节点请求对应交易的merkel proof的哈希值，这些红色的哈希值不断和轻节点自己计算的绿色哈希值再算哈希，最后得到根哈希，完成验证。



## BTC-共识协议

- 数字货币主要问题：花两次攻击 double spending attack 数字货币是一个文件，我复制多份就可以不断花出去。

- 改进方案：给每一个数字货币一个编号，并且记录对应编号的数字货币属于哪个人，每次交易的时候都向央行确认是否匹配。问题：太麻烦，不是去中心化
- 数字货币系统需要解决两个问题：
  - 什么时候谁来发行
  - 怎么处理花两次攻击
- 先设计如何解决花两次攻击：
  - ![image-20230620104730367](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230620104730367.png)
  - 使用区块链——哈希指针来构成交易。比如：最开始有一个铸币交易，A获得了10个币，接下来他把这十个币分发给B和C，并且由A的私钥、B的公钥、C的公钥等信息进行签名，同时A还会有一个指向自己比特币来源的哈希指针。这些共同构成一个交易block。以此类推可以不断交易。当出现非法交易，比如B已经把5个币给被人了，现在又想给F5个币，这个交易block在回溯整个区块链进行验证时候就会发现，B指向的来源已经被B花掉了，交易终止。

- 比特币的地址是由某个人的公钥进行哈希后进行一系列计算得到了。这部分的安全保障基于非对称加密系统。比如有B‘用自己的公钥创建一个交易说转给了B。如何解决这种伪造的问题。其实就是靠指向来源的哈希指针，来源的哈希指针存储了接收方的公钥的哈希值。一个交易发送方地址的哈希和发送方来源的哈希值匹配的时候才知道发送方是合法的。同时交易block本身使用发送方的私钥进行签名。整体保证了安全性。在比特币系统中使用脚本实现。后面细讲。
- block包含什么
- ![image-20230620110634619](https://raw.githubusercontent.com/JeanDiable/MyGallery/main/img/image-20230620110634619.png)
  - block header
    - version
    - hash of previous block header
    - merkel root hash
    - target  H(block header) <= target 
    - nonce
  - block body
    - transaction list

- full node ( fully validating node) 保存所有信息，验证所有交易
- light node 只保存block header， 没法独立验证交易。系统中大部分是轻节点。只是利用区块链的性质和信息做一些查询



- 分布式共识 distributed consensus
  - 分布式哈希表 distributed hash table
  - CAP Theorm 三者只能实现两个
    - Consistency 达成共识
    - Availability 可使用性
    - Partition tolorence
  - 著名协议：Paxos 



- 比特币中的共识
  - 有些节点可能有恶意，如何设计共识协议
    - 是否可以使用投票的方式，超过半数的节点支持创建block，就创建
    - 任何基于投票的方案会涉及到membership的问题，谁有资格投票
    - sybil attack 女巫攻击：有恶意的节点创建超过半数的账户，就获得了投票的掌控权。
  - 简单的投票是不行的，用计算力来投票。每个节点都可以组装出自己认为合法的block，里面包含一堆交易。然后尝试各种nonce值（4bytes），尝试使得H(block header) <= target 。找了符合的nonce获得了记账权。其他节点在这个节点发布之后先验证target是不是符合难度要求，然后nonce是不是符合。之后验证所有的交易，1经过验证，2来源可靠没有被花过。
  - block必须被加在最长合法链子上的。longest valid chain。 对应的可能有forking attack，加载在中间block导致回滚。
  - 如果出现差不多时间两个节点都发布了block，那么会持续一段时间一个节点后面有两个节点的情况，直到某个节点选择了其中一个进行扩展，这个时候就确定了最长合法链，另外一个就变成了orphan block被抛弃。
  - 出块奖励block reward 引出下一个问题：谁来发布比特币：



- 铸币交易 coinbase transaction
  - 唯一可以生产比特币的权限，比特币的唯一来源
  - 前21万个交易节点获得记账权可以获得50个BTC，过了就减半变成25个。再过21万个再减半。





